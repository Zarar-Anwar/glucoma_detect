# -*- coding: utf-8 -*-
"""Untitled22.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1lIGh5ySzqrAUlQd3SYB0V_mxzVv7TXDw
"""

import tensorflow as tf
print(tf. __version__)

import keras
import pickle
import tensorflow as tf
import matplotlib.pyplot as plt
from tensorflow.keras import layers
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers.experimental import preprocessing
import os
current_dir = os.path.dirname(os.path.realpath(__file__))

train_dir = os.path.join(current_dir, "website", "model", "data", "Training")
val_dir = os.path.join(current_dir, "website", "model", "data", "Validating")
test_dir = os.path.join(current_dir, "website", "model", "data", "Testing")

IMAGE_SIZE = (100,100)
trainDataAll = tf.keras.preprocessing.image_dataset_from_directory(train_dir,
                                                                   label_mode = "categorical",
                                                                   image_size = IMAGE_SIZE,
                                                                   shuffle = True )

valDataALL = tf.keras.preprocessing.image_dataset_from_directory(val_dir,
                                                                  label_mode = "categorical",
                                                                  image_size = IMAGE_SIZE,
                                                                  shuffle = False)

testDataALL = tf.keras.preprocessing.image_dataset_from_directory(test_dir,
                                                                  label_mode = "categorical",
                                                                  image_size = IMAGE_SIZE,
                                                                  shuffle = False)

data_augmentation = Sequential([
    preprocessing.RandomFlip("horizontal"),
    preprocessing.RandomRotation(0.2),
    preprocessing.RandomHeight(0.2),
    preprocessing.RandomWidth(0.2),
    preprocessing.RandomZoom(0.2),
    preprocessing.Rescaling(1. /255)
])

y_val_labels = []
for images, labels in valDataALL.unbatch(): # unbatch the test data and get images and labels
    y_val_labels.append(labels.numpy().argmax()) # append the index which has the largest value (labels are one-hot)

y_test_labels = []
for images, labels in testDataALL.unbatch(): # unbatch the test data and get images and labels
    y_test_labels.append(labels.numpy().argmax()) # append the index which has the largest value (labels are one-hot)

class_names = testDataALL.class_names
class_names

# Our function needs a different name to sklearn's plot_confusion_matrix
def make_confusion_matrix(y_true, y_pred, classes=None, figsize=(10, 10), text_size=15):
    """
    Example usage:
    make_confusion_matrix(y_true=test_labels, # ground truth test labels
                          y_pred=y_preds, # predicted labels
                          classes=class_names, # array of class label names
                          figsize=(15, 15),
                          text_size=10)
  """
    # Create the confustion matrix
    cm = confusion_matrix(y_true, y_pred)
    cm_norm = cm.astype("float") / cm.sum(axis=1)[:, np.newaxis] # normalize it
    n_classes = cm.shape[0] # find the number of classes we're dealing with

    # Plot the figure and make it pretty
    fig, ax = plt.subplots(figsize=figsize)
    cax = ax.matshow(cm, cmap=plt.cm.Blues) # colors will represent how 'correct' a class is, darker == better
    fig.colorbar(cax)

    # Are there a list of classes?
    if classes:
        labels = classes
    else:
        labels = np.arange(cm.shape[0])

    # Label the axes
    ax.set(title="Confusion Matrix",
         xlabel="Predicted label",
         ylabel="True label",
         xticks=np.arange(n_classes), # create enough axis slots for each class
         yticks=np.arange(n_classes),
         xticklabels=labels, # axes will labeled with class names (if they exist) or ints
         yticklabels=labels)

     # Make x-axis labels appear on bottom
    ax.xaxis.set_label_position("bottom")
    ax.xaxis.tick_bottom()

   # Set the threshold for different colors
    threshold = (cm.max() + cm.min()) / 2.

    # Plot the text on each cell
    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):
         plt.text(j, i, f"{cm[i, j]} ({cm_norm[i, j]*100:.1f}%)",
             horizontalalignment="center",
             color="white" if cm[i, j] > threshold else "black",
             size=text_size)

import os
import random
import matplotlib.image as mpimg

plt.figure(figsize = (20,12))
for i in range(15):
    ax = plt.subplot(6,6,i+1)
    class_name = random.choice(class_names)
    filename = random.choice(os.listdir(train_dir + "/" + class_name))
    filepath = train_dir + class_name + "/" + filename
    img = mpimg.imread(filepath)
    plt.imshow(img)
    plt.title(class_name)
    plt.axis(False)

# setup a model and freeze its layers
base_model = tf.keras.applications.ResNet50 (weights='imagenet', include_top = False)
base_model.trainable = False


#setup model architecture
inputs = layers.Input( shape = (100,100, 3), name = "input_layer")
x = data_augmentation(inputs)
x = base_model(inputs, training = False)
x = layers.GlobalAveragePooling2D(name = "global_avg_pool")(x)
x = layers.Dropout(0.25)(x)
outputs = layers.Dense(2, activation = "softmax", name = "output_layer")(x)
x = layers.Dropout(0.8)(x)
model1 = tf.keras.Model(inputs, outputs)

model1.compile(loss = "BinaryCrossentropy",  #"categorical_crossentropy",
             optimizer = tf.keras.optimizers.Adam(),
             metrics = ['accuracy'])

from keras.callbacks import Callback, ModelCheckpoint, ReduceLROnPlateau, TensorBoard
filepath = "model1.hdf5"
checkpoint = ModelCheckpoint(filepath, monitor = "val_accuracy", verbose = 1, save_best_only = True, mode = "max")
callbacks_list = [checkpoint]

history1 = model1.fit(trainDataAll,
                     epochs = 50,
                     batch_size = 32,
                     validation_data = valDataALL,
                     validation_steps = len(valDataALL),
                     callbacks = callbacks_list
                    )

model1.evaluate(testDataALL)

y_pred1 = model1.predict(testDataALL)

from sklearn.metrics import accuracy_score
import numpy as np
sklearn_accuracy = accuracy_score(y_test_labels, np.argmax(y_pred1, axis = 1))
print('Accuracy of ResNet50 on Test Data:', sklearn_accuracy)

from sklearn.metrics import classification_report
print(classification_report(y_test_labels, np.argmax(y_pred1, axis = 1), target_names=class_names))

plt.plot(history1.history['loss'], label='train loss')
plt.plot(history1.history['val_loss'], label='val loss')
plt.legend()
plt.show()
# plt.savefig('LossVal_loss')

# plot the accuracy
plt.plot(history1.history['accuracy'], label='train acc')
plt.plot(history1.history['val_accuracy'], label='val acc')
plt.legend()
plt.show()
# plt.savefig('AccVal_acc')
model_file_path = os.path.join(current_dir, "model1.hdf5")
load_model = keras.models.load_model(model_file_path)

import random
import os

plt.figure(figsize=(17, 12))
for i in range(6):
    class_name = random.choice(class_names)
    filename = random.choice(os.listdir(test_dir + "/" + class_name))
    filepath = test_dir + class_name + "/" + filename

    img = tf.io.read_file(filepath)
    img = tf.io.decode_image(img)
    img = tf.image.resize(img, [100,100])

    pred_prob = load_model.predict(tf.expand_dims(img, axis=0)) # model accepts tensors of shape [None, 100,100, 3]
    pred_class = class_names[pred_prob.argmax()] # find the predicted class

    # Plot the image(s)
    plt.subplot(2, 3, i+1)
    plt.imshow(img/255.)
    if class_name == pred_class: # Change the color of text based on whether prediction is right or wrong
        title_color = "g"
    else:
        title_color = "r"
    plt.title(f"Actual: {class_name}, Pred: {pred_class}, Prob: {pred_prob.max():.2f}", c=title_color)
    plt.axis(False);

import random
import os

plt.figure(figsize=(17, 12))
for i in range(6):
    class_name = random.choice(class_names)
    filename = random.choice(os.listdir(test_dir + "/" + class_name))
    filepath = test_dir + class_name + "/" + filename

    img = tf.io.read_file(filepath)
    img = tf.io.decode_image(img)
    img = tf.image.resize(img, [100,100])

    pred_prob = load_model.predict(tf.expand_dims(img, axis=0)) # model accepts tensors of shape [None, 100,100, 3]
    pred_class = class_names[pred_prob.argmax()] # find the predicted class

    # Plot the image(s)
    plt.subplot(2, 3, i+1)
    plt.imshow(img/255.)

    title_color = 'green' if pred_prob.max() >= 0.5 else 'red'
    plt.title(f"Actual: {class_name}, Pred: {pred_class}, Prob: {pred_prob.max():.2f}", c=title_color)
    plt.axis(False);

import random
import os
import matplotlib.pyplot as plt
import tensorflow as tf

# Define your class_names and update the test_dir path
class_names = ["Positive", "Negative",]  # Replace with your class names
test_dir = os.path.join(current_dir, "website", "model", "data", "Testing")

plt.figure(figsize=(17, 12))
for i in range(1):
    class_name = random.choice(class_names)

    # Get a list of filenames for the selected class
    class_dir = os.path.join(test_dir, class_name)
    filenames = os.listdir(class_dir)

    if not filenames:
        continue  # Skip if the class directory is empty

    filename = random.choice(filenames)
    filepath = os.path.join(class_dir, filename)

    img = tf.io.read_file(filepath)
    img = tf.io.decode_image(img)
    img = tf.image.resize(img, [100, 100])

    # Assuming you have a loaded model named 'load_model'
    pred_prob = load_model.predict(tf.expand_dims(img, axis=0))
    pred_class = class_names[pred_prob.argmax()]

    # Plot the image(s)
    plt.subplot(2, 3, i + 1)
    plt.imshow(img / 255.)

    title_color = 'green' if pred_prob.max() >= 0.5 else 'red'

    plt.title(f"Actual: {class_name}, Pred: {pred_class}, Prob: {pred_prob.max():.2f}", color=title_color)
    plt.axis(False)

plt.show()

# ...
import random
import os
import matplotlib.pyplot as plt
import tensorflow as tf

# Define your class_names and update the test_dir path
class_names = ["Positive", "Negative",]  # Replace with your class names
test_dir = os.path.join(current_dir, "website", "model", "data", "Testing")

plt.figure(figsize=(17, 12))
for i in range(1):
    class_name = random.choice(class_names)

    # Get a list of filenames for the selected class
    class_dir = os.path.join(test_dir, class_name)
    filenames = os.listdir(class_dir)

    if not filenames:
        continue  # Skip if the class directory is empty

    filename = random.choice(filenames)
    filepath = os.path.join(class_dir, filename)

    img = tf.io.read_file(filepath)
    img = tf.io.decode_image(img)
    img = tf.image.resize(img, [100, 100])

# Assuming you have a loaded model named 'load_model'
pred_prob = load_model.predict(tf.expand_dims(img, axis=0))
pred_class_index = pred_prob.argmax()

# Ensure that the predicted class is either "Positive" or "Negative"
if pred_class_index == 0:
    pred_class = "Positive"
elif pred_class_index == 1:
    pred_class = "Negative"
else:
    pred_class = "Unknown"

# Plot the image(s)
plt.subplot(2, 3, i + 1)
plt.imshow(img / 255.)

title_color = 'green' if pred_class == class_name else 'red'

plt.title(f"Actual: {class_name}, Pred: {pred_class}, Prob: {pred_prob.max():.2f}", color=title_color)
plt.axis(False)

# ...